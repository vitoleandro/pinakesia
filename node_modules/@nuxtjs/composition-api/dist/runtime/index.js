'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const vue = require('vue');
const globals = require('@nuxtjs/composition-api/dist/runtime/globals');
const defu = require('defu');
const ufo = require('ufo');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const defu__default = /*#__PURE__*/_interopDefaultLegacy(defu);

function validateKey(key) {
  if (!key) {
    throw new Error("You must provide a key. You can have it generated automatically by adding '@nuxtjs/composition-api/dist/babel-plugin' to your Babel plugins.");
  }
}
const getCurrentInstance = () => {
  const vm = vue.getCurrentInstance();
  if (!vm)
    return;
  return vm.proxy;
};

function getValue(value) {
  if (value instanceof Function)
    return value();
  return value;
}
let globalRefs = {};
function setSSRContext(app) {
  globalRefs = Object.assign({}, {});
  app.context.ssrContext.nuxt.globalRefs = globalRefs;
}
const useServerData = () => {
  const vm = getCurrentInstance();
  const type = vm ? "ssrRefs" : "globalRefs";
  let ssrRefs;
  if (vm && process.server) {
    const ssrContext = (vm[globals.globalNuxt] || vm.$options).context.ssrContext;
    ssrRefs = ssrContext.nuxt.ssrRefs = ssrContext.nuxt.ssrRefs || {};
  }
  const setData = (key, val) => {
    const refs = ssrRefs || globalRefs;
    refs[key] = sanitise(val);
  };
  return { type, setData };
};
const isProxyable = (val) => !!val && typeof val === "object";
const sanitise = (val) => val && JSON.parse(JSON.stringify(val)) || val;
const ssrValue = (value, key, type = "globalRefs") => {
  var _a, _b, _c, _d;
  if (process.client) {
    if (process.env.NODE_ENV === "development" && ((_a = window[globals.globalNuxt]) == null ? void 0 : _a.context.isHMR)) {
      return getValue(value);
    }
    return (_d = (_c = (_b = window[globals.globalContext]) == null ? void 0 : _b[type]) == null ? void 0 : _c[key]) != null ? _d : getValue(value);
  }
  return getValue(value);
};
const ssrRef = (value, key) => {
  validateKey(key);
  const { type, setData } = useServerData();
  let val = ssrValue(value, key, type);
  if (process.client)
    return vue.ref(val);
  if (value instanceof Function)
    setData(key, val);
  const getProxy = (track, trigger, observable) => new Proxy(observable, {
    get(target, prop) {
      track();
      if (isProxyable(target[prop]))
        return getProxy(track, trigger, target[prop]);
      const value2 = Reflect.get(target, prop);
      return typeof value2 === "function" ? value2.bind(target) : value2;
    },
    set(obj, prop, newVal) {
      const result = Reflect.set(obj, prop, newVal);
      setData(key, val);
      trigger();
      return result;
    }
  });
  const proxy = vue.customRef((track, trigger) => ({
    get: () => {
      track();
      if (isProxyable(val))
        return getProxy(track, trigger, val);
      return val;
    },
    set: (v) => {
      setData(key, v);
      val = v;
      trigger();
    }
  }));
  return proxy;
};
const shallowSsrRef = (value, key) => {
  validateKey(key);
  const { type, setData } = useServerData();
  if (process.client)
    return vue.shallowRef(ssrValue(value, key, type));
  const _val = getValue(value);
  if (value instanceof Function) {
    setData(key, _val);
  }
  return vue.customRef((track, trigger) => ({
    get() {
      track();
      return _val;
    },
    set(newValue) {
      setData(key, newValue);
      value = newValue;
      trigger();
    }
  }));
};
const ssrPromise = (value, key) => {
  validateKey(key);
  const { type, setData } = useServerData();
  const val = ssrValue(value, key, type);
  if (process.client)
    return Promise.resolve(val);
  vue.onServerPrefetch(async () => {
    setData(key, await val);
  });
  return val;
};

const useAsync = (cb, key) => {
  var _a;
  validateKey(key);
  const _ref = vue.isRef(key) ? key : ssrRef(null, key);
  if (!_ref.value || process.env.NODE_ENV === "development" && process.client && ((_a = window[globals.globalNuxt]) == null ? void 0 : _a.context.isHMR)) {
    const p = Promise.resolve(cb());
    if (process.server) {
      vue.onServerPrefetch(async () => {
        _ref.value = await p;
      });
    } else {
      p.then((res) => _ref.value = res);
    }
  }
  return _ref;
};

function createEmptyMeta() {
  return {
    titleTemplate: null,
    __dangerouslyDisableSanitizers: [],
    __dangerouslyDisableSanitizersByTagID: {},
    title: void 0,
    htmlAttrs: {},
    headAttrs: {},
    bodyAttrs: {},
    base: void 0,
    meta: [],
    link: [],
    style: [],
    script: [],
    noscript: [],
    changed: void 0,
    afterNavigation: void 0
  };
}
const getHeadOptions = (options) => {
  const head = function() {
    const optionHead = options.head instanceof Function ? options.head.call(this) : options.head;
    if (!this._computedHead)
      return optionHead;
    const computedHead = this._computedHead.map((h) => {
      if (vue.isReactive(h))
        return vue.toRaw(h);
      if (vue.isRef(h))
        return h.value;
      return h;
    });
    return defu__default["default"]({}, ...computedHead.reverse(), optionHead);
  };
  return { head };
};
const useMeta = (init) => {
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error("useMeta must be called within a component.");
  if (!("head" in vm.$options))
    throw new Error("In order to enable `useMeta`, please make sure you include `head: {}` within your component definition, and you are using the `defineComponent` exported from @nuxtjs/composition-api.");
  const refreshMeta = () => vm.$meta().refresh();
  if (!vm._computedHead) {
    const metaRefs = vue.reactive(createEmptyMeta());
    vm._computedHead = [metaRefs];
    vm._metaRefs = vue.toRefs(metaRefs);
    if (process.client) {
      vue.watch(Object.values(vm._metaRefs), refreshMeta, { immediate: true });
    }
  }
  if (init) {
    const initRef = init instanceof Function ? vue.computed(init) : vue.ref(init);
    vm._computedHead.push(initRef);
    if (process.client) {
      vue.watch(initRef, refreshMeta, { immediate: true });
    }
  }
  return vm._metaRefs;
};

const defineComponent = (options) => {
  if (!("head" in options))
    return options;
  return {
    ...options,
    ...getHeadOptions(options)
  };
};

const withContext = (callback) => {
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error("This must be called within a setup function.");
  callback((vm[globals.globalNuxt] || vm.$options).context);
};
const useContext = () => {
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error("This must be called within a setup function.");
  return {
    ...(vm[globals.globalNuxt] || vm.$options).context,
    route: vue.computed(() => vm.$route),
    query: vue.computed(() => vm.$route.query),
    from: vue.computed(() => (vm[globals.globalNuxt] || vm.$options).context.from),
    params: vue.computed(() => vm.$route.params)
  };
};

const defineNuxtPlugin = (plugin) => plugin;
const defineNuxtMiddleware = (middleware) => middleware;

const nuxtState = process.client && window[globals.globalContext];
function normalizeError(err) {
  let message;
  if (!(err.message || typeof err === "string")) {
    try {
      message = JSON.stringify(err, null, 2);
    } catch (e) {
      message = `[${err.constructor.name}]`;
    }
  } else {
    message = err.message || err;
  }
  return {
    ...err,
    message,
    statusCode: err.statusCode || err.status || err.response && err.response.status || 500
  };
}
function createGetCounter(counterObject, defaultKey = "") {
  return function getCounter(id = defaultKey) {
    if (counterObject[id] === void 0) {
      counterObject[id] = 0;
    }
    return counterObject[id]++;
  };
}
const fetches = new WeakMap();
const fetchPromises = new Map();
const isSsrHydration = (vm) => {
  var _a, _b, _c;
  return (_c = (_b = (_a = vm.$vnode) == null ? void 0 : _a.elm) == null ? void 0 : _b.dataset) == null ? void 0 : _c.fetchKey;
};
function registerCallback(vm, callback) {
  const callbacks = fetches.get(vm) || [];
  fetches.set(vm, [...callbacks, callback]);
}
async function callFetches() {
  const fetchesToCall = fetches.get(this);
  if (!fetchesToCall)
    return;
  this[globals.globalNuxt].nbFetching++;
  this.$fetchState.pending = true;
  this.$fetchState.error = null;
  this._hydrated = false;
  let error = null;
  const startTime = Date.now();
  try {
    await Promise.all(fetchesToCall.map((fetch) => {
      if (fetchPromises.has(fetch))
        return fetchPromises.get(fetch);
      const promise = Promise.resolve(fetch(this)).finally(() => fetchPromises.delete(fetch));
      fetchPromises.set(fetch, promise);
      return promise;
    }));
  } catch (err) {
    if (process.dev) {
      console.error("Error in fetch():", err);
    }
    error = normalizeError(err);
  }
  const delayLeft = (this._fetchDelay || 0) - (Date.now() - startTime);
  if (delayLeft > 0) {
    await new Promise((resolve) => setTimeout(resolve, delayLeft));
  }
  this.$fetchState.error = error;
  this.$fetchState.pending = false;
  this.$fetchState.timestamp = Date.now();
  this.$nextTick(() => this[globals.globalNuxt].nbFetching--);
}
const setFetchState = (vm) => {
  vm.$fetchState = vm.$fetchState || vue.reactive({
    error: null,
    pending: false,
    timestamp: 0
  });
};
const mergeDataOnMount = (data) => {
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error("This must be called within a setup function.");
  vue.onBeforeMount(() => {
    const vmData = vm._setupProxy || vm;
    for (const key in data) {
      try {
        if (key in vmData) {
          const _key = key;
          if (vmData[_key] === data[key])
            continue;
          if (typeof vmData[_key] === "function")
            continue;
          if (vue.isReactive(vmData[_key])) {
            for (const k in vmData[_key]) {
              if (!(k in data[key])) {
                delete vmData[_key][k];
              }
            }
            Object.assign(vmData[_key], data[key]);
            continue;
          }
        }
        vue.set(vmData, key, data[key]);
      } catch (e) {
        if (process.env.NODE_ENV === "development")
          console.warn(`Could not hydrate ${key}.`);
      }
    }
  });
};
const loadFullStatic = (vm) => {
  vm._fetchKey = getKey(vm);
  const { fetchOnServer } = vm.$options;
  const fetchedOnServer = typeof fetchOnServer === "function" ? fetchOnServer.call(vm) !== false : fetchOnServer !== false;
  const nuxt = vm[globals.globalNuxt];
  if (!fetchedOnServer || (nuxt == null ? void 0 : nuxt.isPreview) || !(nuxt == null ? void 0 : nuxt._pagePayload)) {
    return;
  }
  vm._hydrated = true;
  const data = nuxt._pagePayload.fetch[vm._fetchKey];
  if (data && data._error) {
    vm.$fetchState.error = data._error;
    return;
  }
  mergeDataOnMount(data);
};
async function serverPrefetch(vm) {
  if (!vm._fetchOnServer)
    return;
  setFetchState(vm);
  try {
    await callFetches.call(vm);
  } catch (err) {
    if (process.dev) {
      console.error("Error in fetch():", err);
    }
    vm.$fetchState.error = normalizeError(err);
  }
  vm.$fetchState.pending = false;
  vm._fetchKey = "push" in vm.$ssrContext.nuxt.fetch ? vm.$ssrContext.nuxt.fetch.length : vm._fetchKey || vm.$ssrContext.fetchCounters[""]++;
  if (!vm.$vnode.data)
    vm.$vnode.data = {};
  const attrs = vm.$vnode.data.attrs = vm.$vnode.data.attrs || {};
  attrs["data-fetch-key"] = vm._fetchKey;
  const data = Object.fromEntries(Object.entries((vm == null ? void 0 : vm._setupProxy) || (vm == null ? void 0 : vm._setupState)).filter(([_key, val]) => !(val && typeof val === "object" && "_compiled" in val || val instanceof Function || val instanceof Promise)).map(([key, val]) => [key, vue.isRef(val) ? val.value : val]));
  const content = vm.$fetchState.error ? { _error: vm.$fetchState.error } : JSON.parse(JSON.stringify(data));
  if ("push" in vm.$ssrContext.nuxt.fetch) {
    vm.$ssrContext.nuxt.fetch.push(content);
  } else {
    vm.$ssrContext.nuxt.fetch[vm._fetchKey] = content;
  }
}
function getKey(vm) {
  const nuxtState2 = vm[globals.globalNuxt];
  if (process.server && "push" in vm.$ssrContext.nuxt.fetch) {
    return void 0;
  } else if (process.client && "_payloadFetchIndex" in nuxtState2) {
    nuxtState2._payloadFetchIndex = nuxtState2._payloadFetchIndex || 0;
    return nuxtState2._payloadFetchIndex++;
  }
  const defaultKey = vm.$options._scopeId || vm.$options.name || "";
  const getCounter = createGetCounter(process.server ? vm.$ssrContext.fetchCounters : vm[globals.globalNuxt]._fetchCounters, defaultKey);
  const options = vm.$options;
  if (typeof options.fetchKey === "function") {
    return options.fetchKey.call(vm, getCounter);
  } else {
    const key = typeof options.fetchKey === "string" ? options.fetchKey : defaultKey;
    return key ? key + ":" + getCounter(key) : String(getCounter(key));
  }
}
const useFetch = (callback) => {
  var _a;
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error("This must be called within a setup function.");
  registerCallback(vm, callback);
  if (typeof vm.$options.fetchOnServer === "function") {
    vm._fetchOnServer = vm.$options.fetchOnServer.call(vm) !== false;
  } else {
    vm._fetchOnServer = vm.$options.fetchOnServer !== false;
  }
  if (process.server) {
    vm._fetchKey = getKey(vm);
  }
  setFetchState(vm);
  vue.onServerPrefetch(() => serverPrefetch(vm));
  function result() {
    return {
      fetch: vm.$fetch,
      fetchState: vm.$fetchState,
      $fetch: vm.$fetch,
      $fetchState: vm.$fetchState
    };
  }
  vm._fetchDelay = typeof vm.$options.fetchDelay === "number" ? vm.$options.fetchDelay : 0;
  vm.$fetch = callFetches.bind(vm);
  vue.onBeforeMount(() => !vm._hydrated && callFetches.call(vm));
  if (process.server || !isSsrHydration(vm)) {
    if (process.client && globals.isFullStatic)
      loadFullStatic(vm);
    return result();
  }
  vm._hydrated = true;
  vm._fetchKey = ((_a = vm.$vnode.elm) == null ? void 0 : _a.dataset.fetchKey) || getKey(vm);
  const data = nuxtState.fetch[vm._fetchKey];
  if (data && data._error) {
    vm.$fetchState.error = data._error;
    return result();
  }
  mergeDataOnMount(data);
  return result();
};

const reqRefs = new Set();
const reqRef = (initialValue) => {
  const _ref = vue.ref(initialValue);
  if (process.server)
    reqRefs.add(() => _ref.value = initialValue);
  return _ref;
};
const reqSsrRef = (initialValue, key) => {
  const _ref = ssrRef(initialValue, key);
  if (process.server)
    reqRefs.add(() => {
      _ref.value = initialValue instanceof Function ? sanitise(initialValue()) : initialValue;
    });
  return _ref;
};

let globalSetup;
const onGlobalSetup = (fn) => {
  globalSetup.add(fn);
};
const setMetaPlugin = (context) => {
  const { head } = context.app;
  Object.assign(context.app, getHeadOptions({ head }));
};
const globalPlugin = (context) => {
  if (process.server) {
    reqRefs.forEach((reset) => reset());
    setSSRContext(context.app);
  }
  const { setup } = context.app;
  globalSetup = new Set();
  context.app.setup = function(...args) {
    let result = {};
    if (setup instanceof Function) {
      result = setup(...args) || {};
    }
    for (const fn of globalSetup) {
      result = { ...result, ...fn.call(this, ...args) || {} };
    }
    return result;
  };
};

const staticCache = {};
function writeFile(key, value) {
  if (process.client || !process.static)
    return;
  const { writeFileSync } = process.client ? "" : require("fs");
  const { join } = process.client ? "" : require("pathe");
  try {
    writeFileSync(join(globals.staticPath, `${key}.json`), value);
  } catch (e) {
    console.log(e);
  }
}
const useStatic = (factory, param = vue.ref(""), keyBase) => {
  var _a, _b;
  const key = vue.computed(() => `${keyBase}-${param.value}`);
  const result = ssrRef(null, key.value);
  if (result.value)
    staticCache[key.value] = result.value;
  if (process.client) {
    const publicPath = ((_b = (_a = window[globals.globalContext].$config) == null ? void 0 : _a.app) == null ? void 0 : _b.cdnURL) || globals.publicPath;
    const onFailure = () => factory(param.value, key.value).then((r) => {
      staticCache[key.value] = r;
      result.value = r;
      return;
    });
    vue.watch(key, (key2) => {
      if (key2 in staticCache) {
        result.value = staticCache[key2];
        return;
      }
      if (!process.static)
        onFailure();
      else
        fetch(ufo.joinURL(publicPath, `${key2}.json`)).then((response) => {
          if (!response.ok)
            throw new Error("Response invalid.");
          return response.json();
        }).then((json) => {
          staticCache[key2] = json;
          result.value = json;
        }).catch(onFailure);
    }, {
      immediate: true,
      flush: "post"
    });
  } else {
    if (key.value in staticCache) {
      result.value = staticCache[key.value];
      return result;
    }
    vue.onServerPrefetch(async () => {
      const [_key, _param] = [key.value, param.value];
      result.value = await factory(_param, _key);
      staticCache[_key] = result.value;
      writeFile(_key, JSON.stringify(result.value));
    });
  }
  return result;
};

const wrapProperty = (property, makeComputed) => {
  return () => {
    const vm = getCurrentInstance();
    if (!vm)
      throw new Error("This must be called within a setup function.");
    return makeComputed !== false ? vue.computed(() => vm[property]) : vm[property];
  };
};
const useRouter = wrapProperty("$router", false);
const useRoute = wrapProperty("$route");
const useStore = (key) => {
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error("This must be called within a setup function.");
  return vm.$store;
};

const warn = () => console.warn("`warn` is not exported by Vue 2.7");
const createApp = () => console.warn("`createApp` is not exported by Vue 2.7");
const createRef = () => console.warn("`createRef` is not exported by Vue 2.7");
const defineAsyncComponent = () => console.warn("`defineAsyncComponent` is not exported by Vue 2.7");
const isRaw = () => console.warn("`isRaw` is not exported by Vue 2.7");

Object.defineProperty(exports, 'computed', {
  enumerable: true,
  get: function () { return vue.computed; }
});
Object.defineProperty(exports, 'customRef', {
  enumerable: true,
  get: function () { return vue.customRef; }
});
Object.defineProperty(exports, 'del', {
  enumerable: true,
  get: function () { return vue.del; }
});
Object.defineProperty(exports, 'effectScope', {
  enumerable: true,
  get: function () { return vue.effectScope; }
});
Object.defineProperty(exports, 'getCurrentInstance', {
  enumerable: true,
  get: function () { return vue.getCurrentInstance; }
});
Object.defineProperty(exports, 'getCurrentScope', {
  enumerable: true,
  get: function () { return vue.getCurrentScope; }
});
Object.defineProperty(exports, 'h', {
  enumerable: true,
  get: function () { return vue.h; }
});
Object.defineProperty(exports, 'inject', {
  enumerable: true,
  get: function () { return vue.inject; }
});
Object.defineProperty(exports, 'isProxy', {
  enumerable: true,
  get: function () { return vue.isProxy; }
});
Object.defineProperty(exports, 'isReactive', {
  enumerable: true,
  get: function () { return vue.isReactive; }
});
Object.defineProperty(exports, 'isReadonly', {
  enumerable: true,
  get: function () { return vue.isReadonly; }
});
Object.defineProperty(exports, 'isRef', {
  enumerable: true,
  get: function () { return vue.isRef; }
});
Object.defineProperty(exports, 'isShallow', {
  enumerable: true,
  get: function () { return vue.isShallow; }
});
Object.defineProperty(exports, 'markRaw', {
  enumerable: true,
  get: function () { return vue.markRaw; }
});
Object.defineProperty(exports, 'nextTick', {
  enumerable: true,
  get: function () { return vue.nextTick; }
});
Object.defineProperty(exports, 'onActivated', {
  enumerable: true,
  get: function () { return vue.onActivated; }
});
Object.defineProperty(exports, 'onBeforeMount', {
  enumerable: true,
  get: function () { return vue.onBeforeMount; }
});
Object.defineProperty(exports, 'onBeforeUnmount', {
  enumerable: true,
  get: function () { return vue.onBeforeUnmount; }
});
Object.defineProperty(exports, 'onBeforeUpdate', {
  enumerable: true,
  get: function () { return vue.onBeforeUpdate; }
});
Object.defineProperty(exports, 'onDeactivated', {
  enumerable: true,
  get: function () { return vue.onDeactivated; }
});
Object.defineProperty(exports, 'onErrorCaptured', {
  enumerable: true,
  get: function () { return vue.onErrorCaptured; }
});
Object.defineProperty(exports, 'onMounted', {
  enumerable: true,
  get: function () { return vue.onMounted; }
});
Object.defineProperty(exports, 'onRenderTracked', {
  enumerable: true,
  get: function () { return vue.onRenderTracked; }
});
Object.defineProperty(exports, 'onRenderTriggered', {
  enumerable: true,
  get: function () { return vue.onRenderTriggered; }
});
Object.defineProperty(exports, 'onScopeDispose', {
  enumerable: true,
  get: function () { return vue.onScopeDispose; }
});
Object.defineProperty(exports, 'onServerPrefetch', {
  enumerable: true,
  get: function () { return vue.onServerPrefetch; }
});
Object.defineProperty(exports, 'onUnmounted', {
  enumerable: true,
  get: function () { return vue.onUnmounted; }
});
Object.defineProperty(exports, 'onUpdated', {
  enumerable: true,
  get: function () { return vue.onUpdated; }
});
Object.defineProperty(exports, 'provide', {
  enumerable: true,
  get: function () { return vue.provide; }
});
Object.defineProperty(exports, 'proxyRefs', {
  enumerable: true,
  get: function () { return vue.proxyRefs; }
});
Object.defineProperty(exports, 'reactive', {
  enumerable: true,
  get: function () { return vue.reactive; }
});
Object.defineProperty(exports, 'readonly', {
  enumerable: true,
  get: function () { return vue.readonly; }
});
Object.defineProperty(exports, 'ref', {
  enumerable: true,
  get: function () { return vue.ref; }
});
Object.defineProperty(exports, 'set', {
  enumerable: true,
  get: function () { return vue.set; }
});
Object.defineProperty(exports, 'shallowReactive', {
  enumerable: true,
  get: function () { return vue.shallowReactive; }
});
Object.defineProperty(exports, 'shallowReadonly', {
  enumerable: true,
  get: function () { return vue.shallowReadonly; }
});
Object.defineProperty(exports, 'shallowRef', {
  enumerable: true,
  get: function () { return vue.shallowRef; }
});
Object.defineProperty(exports, 'toRaw', {
  enumerable: true,
  get: function () { return vue.toRaw; }
});
Object.defineProperty(exports, 'toRef', {
  enumerable: true,
  get: function () { return vue.toRef; }
});
Object.defineProperty(exports, 'toRefs', {
  enumerable: true,
  get: function () { return vue.toRefs; }
});
Object.defineProperty(exports, 'triggerRef', {
  enumerable: true,
  get: function () { return vue.triggerRef; }
});
Object.defineProperty(exports, 'unref', {
  enumerable: true,
  get: function () { return vue.unref; }
});
Object.defineProperty(exports, 'useAttrs', {
  enumerable: true,
  get: function () { return vue.useAttrs; }
});
Object.defineProperty(exports, 'useCSSModule', {
  enumerable: true,
  get: function () { return vue.useCssModule; }
});
Object.defineProperty(exports, 'useCssModule', {
  enumerable: true,
  get: function () { return vue.useCssModule; }
});
Object.defineProperty(exports, 'useCssVars', {
  enumerable: true,
  get: function () { return vue.useCssVars; }
});
Object.defineProperty(exports, 'useSlots', {
  enumerable: true,
  get: function () { return vue.useSlots; }
});
Object.defineProperty(exports, 'version', {
  enumerable: true,
  get: function () { return vue.version; }
});
Object.defineProperty(exports, 'watch', {
  enumerable: true,
  get: function () { return vue.watch; }
});
Object.defineProperty(exports, 'watchEffect', {
  enumerable: true,
  get: function () { return vue.watchEffect; }
});
Object.defineProperty(exports, 'watchPostEffect', {
  enumerable: true,
  get: function () { return vue.watchPostEffect; }
});
Object.defineProperty(exports, 'watchSyncEffect', {
  enumerable: true,
  get: function () { return vue.watchSyncEffect; }
});
exports.createApp = createApp;
exports.createRef = createRef;
exports.defineAsyncComponent = defineAsyncComponent;
exports.defineComponent = defineComponent;
exports.defineNuxtMiddleware = defineNuxtMiddleware;
exports.defineNuxtPlugin = defineNuxtPlugin;
exports.globalPlugin = globalPlugin;
exports.isRaw = isRaw;
exports.onGlobalSetup = onGlobalSetup;
exports.reqRef = reqRef;
exports.reqSsrRef = reqSsrRef;
exports.setMetaPlugin = setMetaPlugin;
exports.setSSRContext = setSSRContext;
exports.shallowSsrRef = shallowSsrRef;
exports.ssrPromise = ssrPromise;
exports.ssrRef = ssrRef;
exports.useAsync = useAsync;
exports.useContext = useContext;
exports.useFetch = useFetch;
exports.useMeta = useMeta;
exports.useRoute = useRoute;
exports.useRouter = useRouter;
exports.useStatic = useStatic;
exports.useStore = useStore;
exports.warn = warn;
exports.withContext = withContext;
exports.wrapProperty = wrapProperty;
