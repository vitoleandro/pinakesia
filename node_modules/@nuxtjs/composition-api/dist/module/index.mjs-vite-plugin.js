import crypto from 'crypto';
import MagicString from 'magic-string';
import { walk } from 'estree-walker';

function createKey(source, method = "base64") {
  const hash = crypto.createHash("md5");
  hash.update(source);
  return hash.digest(method).toString();
}
function compositionApiPlugin() {
  return {
    name: "nuxt:composition-api",
    enforce: "pre",
    transform(code, filename) {
      const keyedFunctions = /(useStatic|shallowSsrRef|ssrPromise|ssrRef|reqSsrRef|useAsync)/;
      if (!keyedFunctions.test(code)) {
        return {
          code,
          map: null
        };
      }
      try {
        const { 0: script = code, index: codeIndex = 0 } = code.match(/(?<=<script[^>]*>)[\S\s.]*?(?=<\/script>)/) || [];
        const ast = this.parse(script);
        const s = new MagicString(code);
        walk(ast, {
          enter(node) {
            var _a, _b;
            const { end } = node;
            const { callee, arguments: args = [] } = node;
            if ((callee == null ? void 0 : callee.type) === "Identifier" || ((_a = callee == null ? void 0 : callee.property) == null ? void 0 : _a.type) === "Identifier") {
              let method = "base64";
              switch (callee.name || ((_b = callee.property) == null ? void 0 : _b.name)) {
                case "useStatic":
                  if (args.length > 2)
                    return;
                  if (args.length === 2) {
                    s.prependLeft(codeIndex + end - 1, ", undefined");
                  }
                  method = "hex";
                  break;
                case "shallowSsrRef":
                case "ssrPromise":
                case "ssrRef":
                case "reqSsrRef":
                case "useAsync":
                  if (args.length > 1)
                    return;
                  break;
                default:
                  return;
              }
              s.appendLeft(codeIndex + end - 1, ", '" + createKey(`${filename}-${end}`, method) + "'");
            }
          }
        });
        return {
          code: s.toString(),
          map: s.generateMap({ source: filename }).toString()
        };
      } catch (e) {
      }
    }
  };
}

export { compositionApiPlugin };
